// megafunction wizard: %ALTUFM_SPI%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: ALTUFM_SPI 

// ============================================================
// File Name: spi.v
// Megafunction Name(s):
// 			ALTUFM_SPI
//
// Simulation Library Files(s):
// 			maxii
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 12.1 Build 243 01/31/2013 SP 1 SJ Web Edition
// ************************************************************


//Copyright (C) 1991-2012 Altera Corporation
//Your use of Altera Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Altera Program License 
//Subscription Agreement, Altera MegaCore Function License 
//Agreement, or other applicable license agreement, including, 
//without limitation, that your use is for the sole purpose of 
//programming logic devices manufactured by Altera and sold by 
//Altera or its authorized distributors.  Please refer to the 
//applicable agreement for further details.


//altufm_spi ACCESS_MODE="READ_ONLY" BYTE_OF_PAGE_WRITE=8 CBX_AUTO_BLACKBOX="ALL" CONFIG_MODE="EXTENDED" DEVICE_FAMILY="MAX II" ERASE_TIME=500000000 LPM_FILE="/home/jiakai/document/original/thu/2013-spring/assignment/digit-circuit/blxlrsmb/gen/mem.mif" OSC_FREQUENCY=180000 PROGRAM_TIME=1600000 WIDTH_UFM_ADDRESS=9 ncs sck si so
//VERSION_BEGIN 12.1SP1 cbx_a_gray2bin 2013:01:31:18:04:54:SJ cbx_a_graycounter 2013:01:31:18:04:54:SJ cbx_altufm_spi 2013:01:31:18:04:55:SJ cbx_cycloneii 2013:01:31:18:04:55:SJ cbx_lpm_add_sub 2013:01:31:18:04:55:SJ cbx_lpm_compare 2013:01:31:18:04:55:SJ cbx_lpm_counter 2013:01:31:18:04:55:SJ cbx_lpm_decode 2013:01:31:18:04:55:SJ cbx_lpm_mux 2013:01:31:18:04:55:SJ cbx_maxii 2013:01:31:18:04:55:SJ cbx_mgl 2013:01:31:18:08:38:SJ cbx_stratix 2013:01:31:18:04:55:SJ cbx_stratixii 2013:01:31:18:04:55:SJ cbx_util_mgl 2013:01:31:18:04:55:SJ  VERSION_END
// synthesis VERILOG_INPUT_VERSION VERILOG_2001
// altera message_off 10463


//synthesis_resources = lpm_counter 3 lut 29 maxii_ufm 1 TRI 1 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
(* ALTERA_ATTRIBUTE = {"suppress_da_rule_internal=c101;suppress_da_rule_internal=c103;suppress_da_rule_internal=c104;suppress_da_rule_internal=c106;suppress_da_rule_internal=d101;suppress_da_rule_internal=r101;suppress_da_rule_internal=s102;suppress_da_rule_internal=s104"} *)
module  spi_altufm_spi_u7t
	( 
	ncs,
	sck,
	si,
	so) /* synthesis synthesis_clearbox=2 */;
	input   ncs;
	input   sck;
	input   si;
	output   so;

	reg	addr_stdly_reg;
	reg	dffe10;
	reg	dffe12;
	reg	dffe13;
	reg	dffe2;
	reg	dffe4;
	wire	[7:0]	wire_dffe5a_d;
	reg	[7:0]	dffe5a;
	wire	[7:0]	wire_dffe5a_ena;
	reg	dffe6;
	wire	[7:0]	wire_dffe7a_d;
	reg	[7:0]	dffe7a;
	wire	[7:0]	wire_dffe7a_ena;
	reg	dffe8;
	reg	dffe9;
	wire  [3:0]   wire_cntr11_q;
	wire  [3:0]   wire_cntr14_q;
	wire  [2:0]   wire_cntr3_q;
	wire  wire_maxii_ufm_block1_bgpbusy;
	wire  wire_maxii_ufm_block1_busy;
	wire  wire_maxii_ufm_block1_drdout;
	wire  wire_maxii_ufm_block1_osc;
	wire	wire_tri_buf15_out;
	wire	wire_tri_buf15_oe;
	wire  addr_complete;
	wire  addr_complete_state;
	wire  addr_state;
	wire  addr_stdly;
	wire  circuit_reset;
	wire  data_complete;
	wire  data_state;
	wire  ncs_wire;
	wire  op_complete;
	wire  op_complete_state;
	wire  op_state;
	wire oscena;
	wire  read_op;
	wire  read_op_state;
	wire  sck_wire;
	wire  si_wire;
	wire  so_wire;
	wire  ufm_arclk;
	wire  ufm_ardin;
	wire  ufm_arshft;
	wire  ufm_bgpbusy;
	wire  ufm_busy;
	wire  ufm_drclk;
	wire  ufm_drdin;
	wire  ufm_drdout;
	wire  ufm_drshft;
	wire  ufm_erase;
	wire  ufm_oscena;
	wire  ufm_program;

	// synopsys translate_off
	initial
		addr_stdly_reg = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire)
		  addr_stdly_reg <= addr_state;
	// synopsys translate_off
	initial
		dffe10 = 0;
	// synopsys translate_on
	always @ ( posedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe10 <= 1'b0;
		else if  (ncs_wire == 1'b0)   dffe10 <= ((op_complete & read_op) & (~ addr_complete));
	// synopsys translate_off
	initial
		dffe12 = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe12 <= 1'b0;
		else if  (ncs_wire == 1'b0)   dffe12 <= addr_complete;
	// synopsys translate_off
	initial
		dffe13 = 0;
	// synopsys translate_on
	always @ ( posedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe13 <= 1'b0;
		else if  (ncs_wire == 1'b0)   dffe13 <= (addr_complete & read_op);
	// synopsys translate_off
	initial
		dffe2 = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe2 <= 1'b0;
		else if  (ncs_wire == 1'b0)   dffe2 <= (~ op_complete);
	// synopsys translate_off
	initial
		dffe4 = 0;
	// synopsys translate_on
	always @ ( posedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe4 <= 1'b0;
		else if  (ncs_wire == 1'b0)   dffe4 <= op_complete;
	// synopsys translate_off
	initial
		dffe5a[0:0] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe5a[0:0] <= 1'b0;
		else if  (wire_dffe5a_ena[0:0] == 1'b1)   dffe5a[0:0] <= wire_dffe5a_d[0:0];
	// synopsys translate_off
	initial
		dffe5a[1:1] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe5a[1:1] <= 1'b0;
		else if  (wire_dffe5a_ena[1:1] == 1'b1)   dffe5a[1:1] <= wire_dffe5a_d[1:1];
	// synopsys translate_off
	initial
		dffe5a[2:2] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe5a[2:2] <= 1'b0;
		else if  (wire_dffe5a_ena[2:2] == 1'b1)   dffe5a[2:2] <= wire_dffe5a_d[2:2];
	// synopsys translate_off
	initial
		dffe5a[3:3] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe5a[3:3] <= 1'b0;
		else if  (wire_dffe5a_ena[3:3] == 1'b1)   dffe5a[3:3] <= wire_dffe5a_d[3:3];
	// synopsys translate_off
	initial
		dffe5a[4:4] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe5a[4:4] <= 1'b0;
		else if  (wire_dffe5a_ena[4:4] == 1'b1)   dffe5a[4:4] <= wire_dffe5a_d[4:4];
	// synopsys translate_off
	initial
		dffe5a[5:5] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe5a[5:5] <= 1'b0;
		else if  (wire_dffe5a_ena[5:5] == 1'b1)   dffe5a[5:5] <= wire_dffe5a_d[5:5];
	// synopsys translate_off
	initial
		dffe5a[6:6] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe5a[6:6] <= 1'b0;
		else if  (wire_dffe5a_ena[6:6] == 1'b1)   dffe5a[6:6] <= wire_dffe5a_d[6:6];
	// synopsys translate_off
	initial
		dffe5a[7:7] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe5a[7:7] <= 1'b0;
		else if  (wire_dffe5a_ena[7:7] == 1'b1)   dffe5a[7:7] <= wire_dffe5a_d[7:7];
	assign
		wire_dffe5a_d = {dffe5a[6:0], dffe6};
	assign
		wire_dffe5a_ena = {8{((((~ ncs_wire) & op_state) & (~ op_complete_state)) & (~ ufm_bgpbusy))}};
	// synopsys translate_off
	initial
		dffe6 = 0;
	// synopsys translate_on
	always @ ( posedge sck_wire)
		if (ncs_wire == 1'b0)   dffe6 <= si;
	// synopsys translate_off
	initial
		dffe7a[0:0] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe7a[0:0] <= 1'b0;
		else if  (wire_dffe7a_ena[0:0] == 1'b1)   dffe7a[0:0] <= wire_dffe7a_d[0:0];
	// synopsys translate_off
	initial
		dffe7a[1:1] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe7a[1:1] <= 1'b0;
		else if  (wire_dffe7a_ena[1:1] == 1'b1)   dffe7a[1:1] <= wire_dffe7a_d[1:1];
	// synopsys translate_off
	initial
		dffe7a[2:2] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe7a[2:2] <= 1'b0;
		else if  (wire_dffe7a_ena[2:2] == 1'b1)   dffe7a[2:2] <= wire_dffe7a_d[2:2];
	// synopsys translate_off
	initial
		dffe7a[3:3] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe7a[3:3] <= 1'b0;
		else if  (wire_dffe7a_ena[3:3] == 1'b1)   dffe7a[3:3] <= wire_dffe7a_d[3:3];
	// synopsys translate_off
	initial
		dffe7a[4:4] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe7a[4:4] <= 1'b0;
		else if  (wire_dffe7a_ena[4:4] == 1'b1)   dffe7a[4:4] <= wire_dffe7a_d[4:4];
	// synopsys translate_off
	initial
		dffe7a[5:5] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe7a[5:5] <= 1'b0;
		else if  (wire_dffe7a_ena[5:5] == 1'b1)   dffe7a[5:5] <= wire_dffe7a_d[5:5];
	// synopsys translate_off
	initial
		dffe7a[6:6] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe7a[6:6] <= 1'b0;
		else if  (wire_dffe7a_ena[6:6] == 1'b1)   dffe7a[6:6] <= wire_dffe7a_d[6:6];
	// synopsys translate_off
	initial
		dffe7a[7:7] = 0;
	// synopsys translate_on
	always @ ( negedge sck_wire or  posedge circuit_reset)
		if (circuit_reset == 1'b1) dffe7a[7:7] <= 1'b0;
		else if  (wire_dffe7a_ena[7:7] == 1'b1)   dffe7a[7:7] <= wire_dffe7a_d[7:7];
	assign
		wire_dffe7a_d = {dffe7a[6:0], dffe8};
	assign
		wire_dffe7a_ena = {8{(((~ ncs_wire) & op_state) & (~ op_complete_state))}};
	// synopsys translate_off
	initial
		dffe8 = 0;
	// synopsys translate_on
	always @ ( posedge sck_wire)
		if (ncs_wire == 1'b0)   dffe8 <= si;
	// synopsys translate_off
	initial
		dffe9 = 0;
	// synopsys translate_on
	always @ ( posedge sck_wire)
		if (ncs_wire == 1'b0)   dffe9 <= (((op_complete_state & read_op) & (~ ufm_busy)) & (~ ufm_bgpbusy));
	lpm_counter   cntr11
	( 
	.aclr(circuit_reset),
	.clk_en((((~ ncs_wire) & (~ addr_complete)) & addr_state)),
	.clock(sck_wire),
	.cout(),
	.eq(),
	.q(wire_cntr11_q)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aload(1'b0),
	.aset(1'b0),
	.cin(1'b1),
	.cnt_en(1'b1),
	.data({4{1'b0}}),
	.sclr(1'b0),
	.sload(1'b0),
	.sset(1'b0),
	.updown(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		cntr11.lpm_direction = "UP",
		cntr11.lpm_port_updown = "PORT_UNUSED",
		cntr11.lpm_width = 4,
		cntr11.lpm_type = "lpm_counter";
	lpm_counter   cntr14
	( 
	.aclr(circuit_reset),
	.clk_en((((~ ncs_wire) & read_op) & data_state)),
	.clock(sck_wire),
	.cout(),
	.eq(),
	.q(wire_cntr14_q)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aload(1'b0),
	.aset(1'b0),
	.cin(1'b1),
	.cnt_en(1'b1),
	.data({4{1'b0}}),
	.sclr(1'b0),
	.sload(1'b0),
	.sset(1'b0),
	.updown(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		cntr14.lpm_direction = "UP",
		cntr14.lpm_port_updown = "PORT_UNUSED",
		cntr14.lpm_width = 4,
		cntr14.lpm_type = "lpm_counter";
	lpm_counter   cntr3
	( 
	.aclr(circuit_reset),
	.clk_en((((~ ncs_wire) & (~ op_complete)) & op_state)),
	.clock((~ sck_wire)),
	.cout(),
	.eq(),
	.q(wire_cntr3_q)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aload(1'b0),
	.aset(1'b0),
	.cin(1'b1),
	.cnt_en(1'b1),
	.data({3{1'b0}}),
	.sclr(1'b0),
	.sload(1'b0),
	.sset(1'b0),
	.updown(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		cntr3.lpm_direction = "UP",
		cntr3.lpm_port_updown = "PORT_UNUSED",
		cntr3.lpm_width = 3,
		cntr3.lpm_type = "lpm_counter";
	maxii_ufm   maxii_ufm_block1
	( 
	.arclk(ufm_arclk),
	.ardin(ufm_ardin),
	.arshft(ufm_arshft),
	.bgpbusy(wire_maxii_ufm_block1_bgpbusy),
	.busy(wire_maxii_ufm_block1_busy),
	.drclk(ufm_drclk),
	.drdin(ufm_drdin),
	.drdout(wire_maxii_ufm_block1_drdout),
	.drshft(ufm_drshft),
	.erase(ufm_erase),
	.osc(wire_maxii_ufm_block1_osc),
	.oscena(ufm_oscena),
	.program(ufm_program)
	// synopsys translate_off
	,
	.ctrl_bgpbusy(1'b0),
	.devclrn(1'b1),
	.devpor(1'b1),
	.sbdin(1'b0),
	.sbdout()
	// synopsys translate_on
	);
	defparam
		maxii_ufm_block1.address_width = 9,
		maxii_ufm_block1.erase_time = 500000000,
		maxii_ufm_block1.init_file = "/home/jiakai/document/original/thu/2013-spring/assignment/digit-circuit/blxlrsmb/gen/mem.mif",
		maxii_ufm_block1.mem1 = 512'h000000000000000000000000000000000000000000000000000000000000000000000000000002FD000403030102020201050101000100020B0C090B07080506,
		maxii_ufm_block1.mem10 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem11 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem12 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem13 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem14 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem15 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem16 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem2 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem3 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem4 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem5 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem6 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem7 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem8 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.mem9 = 512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
		maxii_ufm_block1.osc_sim_setting = 180000,
		maxii_ufm_block1.program_time = 1600000,
		maxii_ufm_block1.lpm_type = "maxii_ufm";
	assign	wire_tri_buf15_out = (wire_tri_buf15_oe === 1'b1) ? ufm_drdout : 1'bz;
	assign
		wire_tri_buf15_oe = (((read_op & read_op_state) & (data_state | (addr_stdly & addr_complete_state))) & (~ ncs_wire));
	assign
		addr_complete = (((wire_cntr11_q[0] & wire_cntr11_q[1]) & wire_cntr11_q[2]) & wire_cntr11_q[3]),
		addr_complete_state = dffe12,
		addr_state = dffe10,
		addr_stdly = addr_stdly_reg,
		circuit_reset = ncs_wire,
		data_complete = (((wire_cntr14_q[0] & wire_cntr14_q[1]) & wire_cntr14_q[2]) & wire_cntr14_q[3]),
		data_state = dffe13,
		ncs_wire = ncs,
		op_complete = ((wire_cntr3_q[0] & wire_cntr3_q[1]) & wire_cntr3_q[2]),
		op_complete_state = dffe4,
		op_state = dffe2,
		oscena = 1'b1,
		read_op = ((((((((~ dffe5a[7]) & (~ dffe5a[6])) & (~ dffe5a[5])) & (~ dffe5a[4])) & (~ dffe5a[3])) & (~ dffe5a[2])) & dffe5a[1]) & dffe5a[0]),
		read_op_state = dffe9,
		sck_wire = sck,
		si_wire = si,
		so = so_wire,
		so_wire = wire_tri_buf15_out,
		ufm_arclk = (((sck_wire & addr_state) & (~ addr_complete_state)) | (wire_cntr14_q[3] & read_op_state)),
		ufm_ardin = (si_wire & (~ ufm_bgpbusy)),
		ufm_arshft = ((op_complete & read_op) & (~ addr_complete_state)),
		ufm_bgpbusy = wire_maxii_ufm_block1_bgpbusy,
		ufm_busy = wire_maxii_ufm_block1_busy,
		ufm_drclk = ((~ sck_wire) & (~ ufm_bgpbusy)),
		ufm_drdin = 1'b0,
		ufm_drdout = wire_maxii_ufm_block1_drdout,
		ufm_drshft = (~ (((addr_state & addr_complete) | data_complete) & read_op_state)),
		ufm_erase = 1'b0,
		ufm_oscena = oscena,
		ufm_program = 1'b0;
endmodule //spi_altufm_spi_u7t
//VALID FILE


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module spi (
	ncs,
	sck,
	si,
	so)/* synthesis synthesis_clearbox = 2 */;

	input	  ncs;
	input	  sck;
	input	  si;
	output	  so;

	wire  sub_wire0;
	wire  so = sub_wire0;

	spi_altufm_spi_u7t	spi_altufm_spi_u7t_component (
				.ncs (ncs),
				.sck (sck),
				.si (si),
				.so (sub_wire0))/* synthesis synthesis_clearbox=2
	 clearbox_macroname = ALTUFM_SPI
	 clearbox_defparam = "access_mode=READ_ONLY;byte_of_page_write=8;config_mode=EXTENDED;erase_time=500000000;intended_device_family=MAX II;lpm_file=/home/jiakai/document/original/thu/2013-spring/assignment/digit-circuit/blxlrsmb/gen/mem.mif;lpm_hint=UNUSED;lpm_type=altufm_spi;osc_frequency=180000;program_time=1600000;width_ufm_address=9;" */;

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "MAX II"
// Retrieval info: PRIVATE: OSC_PORT STRING "OFF"
// Retrieval info: CONSTANT: ACCESS_MODE STRING "READ_ONLY"
// Retrieval info: CONSTANT: BYTE_OF_PAGE_WRITE NUMERIC "8"
// Retrieval info: CONSTANT: CONFIG_MODE STRING "EXTENDED"
// Retrieval info: CONSTANT: ERASE_TIME NUMERIC "500000000"
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "MAX II"
// Retrieval info: CONSTANT: LPM_FILE STRING "/home/jiakai/document/original/thu/2013-spring/assignment/digit-circuit/blxlrsmb/gen/mem.mif"
// Retrieval info: CONSTANT: LPM_HINT STRING "UNUSED"
// Retrieval info: CONSTANT: LPM_TYPE STRING "altufm_spi"
// Retrieval info: CONSTANT: OSC_FREQUENCY NUMERIC "180000"
// Retrieval info: CONSTANT: PROGRAM_TIME NUMERIC "1600000"
// Retrieval info: CONSTANT: WIDTH_UFM_ADDRESS NUMERIC "9"
// Retrieval info: USED_PORT: ncs 0 0 0 0 INPUT NODEFVAL "ncs"
// Retrieval info: CONNECT: @ncs 0 0 0 0 ncs 0 0 0 0
// Retrieval info: USED_PORT: sck 0 0 0 0 INPUT NODEFVAL "sck"
// Retrieval info: CONNECT: @sck 0 0 0 0 sck 0 0 0 0
// Retrieval info: USED_PORT: si 0 0 0 0 INPUT NODEFVAL "si"
// Retrieval info: CONNECT: @si 0 0 0 0 si 0 0 0 0
// Retrieval info: USED_PORT: so 0 0 0 0 OUTPUT NODEFVAL "so"
// Retrieval info: CONNECT: so 0 0 0 0 @so 0 0 0 0
// Retrieval info: GEN_FILE: TYPE_NORMAL spi.v TRUE FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL spi.qip TRUE FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL spi.bsf TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL spi_inst.v TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL spi_bb.v TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL spi.inc TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL spi.cmp TRUE TRUE
// Retrieval info: LIB_FILE: maxii
